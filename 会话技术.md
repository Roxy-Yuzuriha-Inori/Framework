# 会话
## 概念
浏览器关闭之前都属于一次会话<br>
一次会话可包含多次请求
## 会话跟踪
服务器识别多次请求是否来自于同一浏览器，以确认是否是同一次会话，以便共享数据
## 会话跟踪方案
目的：在同一次会话里的多次请求中共享数据<br>
客户端会话跟踪技术：Cookie<br>
服务端会话跟踪技术：Session<br>
令牌技术

## Cookie
存在用户浏览器中<br>
用户通过浏览器第一次访问某个服务器，服务器自动会将cookie返回给用户浏览器<br>
用户浏览器自动会将返回的cookie存在浏览器中<br>
对于后续的请求，会自动携带cookie去访问服务器
### 优点
因为 cookie 它是 HTP 协议当中所支持的技术，而各大浏览器厂商都支持了这一标准。在 HTTP 协议官方给我们提供了一个响应头和请求头：<br>
- 响应头 Set-Cookie ：设置Cookie数据的<br>
- 请求头 Cookie：携带Cookie数据的<br>
```java
@Slf4j
@RestController
public class CookieController {

    //设置Cookie
    @GetMapping("/c1")
    public Result cookie1(HttpServletResponse response){
        //设置响应头Set-Cookie：login_username=itheima
        response.addCookie(new Cookie("login_username","itheima")); 
        return Result.success();
    }
        
    //获取Cookie
    @GetMapping("/c2")
    public Result cookie2(HttpServletRequest request){
        Cookie[] cookies = request.getCookies();
        //从携带的所有cookie进行遍历
        for (Cookie cookie : cookies) {
            if(cookie.getName().equals("login_username")){
                System.out.println("login_username: "+cookie.getValue()); //输出name为login_username的cookie
            }
        }
        return Result.success();
    }
}    
```
### 缺点
  - 移动端APP(Android、IOS)中无法使用Cookie<br>
  - 不安全，用户可以自己禁用Cookie  控制台-应用-cookies<br>
  - Cookie不能跨域<br>

## Session
- 存在一台服务器中<br>
- 本质还是cookie,只用cookie存JSESSIONID
- 用户通过浏览器第一次访问某个服务器，服务器通常自动会将session id 放在cookie返回给用户浏览器<br>
- 用户浏览器自动会将返回的cookie中的session id存在浏览器中<br>
- 对于后续的请求，会自动携带cookie去访问服务器
** 相比cookie，一个是在用户浏览器中用cookie存所有数据，另一个则是在用户浏览器中用cookie只存sessionid **

```java
@Slf4j
@RestController
public class SessionController {

    @GetMapping("/s1")
    public Result session1(HttpSession session){
        log.info("HttpSession-s1: {}", session.hashCode());

        session.setAttribute("loginUser", "tom"); //往session中存储数据
        return Result.success();
    }

    @GetMapping("/s2")
    public Result session2(HttpServletRequest request){
        HttpSession session = request.getSession();  //会通过sessionid匹配到同一个session
        log.info("HttpSession-s2: {}", session.hashCode());

        Object loginUser = session.getAttribute("loginUser"); //从session中获取数据
        log.info("loginUser: {}", loginUser);
        return Result.success(loginUser);
    }
}
```
### 优点
数据存在服务器端，安全
### 缺点
cookie的所有缺点<br>
数据只存一台服务器，然而一般是集群服务器，防止一台服务器挂了就全完了，然后会有一台负载均衡浏览器对集群服务器进行分配，如果没分配到同一台服务器就没session存的数据了

## 令牌技术
- 令牌存在cookie或其他的存储空间(比如：localStorage)当中，共享数据存在令牌第二部分里面
### JWT令牌的组成
- Header（头）， 记录令牌类型、签名算法等。 例如：{"alg":"HS256","type":"JWT"}，原本字符串，然后转成base64
- Payload（有效载荷），携带自定义共享数据等。 例如：{"id":"1","username":"Tom"}，原本字符串，然后转成base64
- Signature（签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，然后通过指定签名算法计算而来。
### JWT令牌的生成和校验
``` xml
<!-- JWT依赖-->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```
** JWT令牌生成 **
```java
@Test
public void testGenJwt() {
    //要共享的数据
    Map<String, Object> claims = new HashMap<>();
    claims.put("id", 10);
    claims.put("username", "itheima");

    //调用 Jwts.builder() 生成令牌
    //.signWith形参 指定签名算法，指定密钥
    //.addClaims 第二部分自定义共享数据
    //.setExpiration 设置有效期，当前系统时间 + 要持续的时间
    //.compact 生成令牌
    String jwt = Jwts.builder().signWith(SignatureAlgorithm.HS256, "aXRjYXN0")
        .addClaims(claims)
        .setExpiration(new Date(System.currentTimeMillis() + 12 * 3600 * 1000))
        .compact();

    System.out.println(jwt);
}
```
** JWT令牌校验 **
``` java
@Test
public void testParseJwt() {

    //调用 Jwt.parser() 解析令牌
    //.setSigningKey 与生成时相同的密钥
    //.parseClaimsJws(JWT).getBody()解析获取第二部分共享数据，json格式
    Claims claims = Jwts.parser().setSigningKey("aXRjYXN0")
        .parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MTAsInVzZXJuYW1lIjoiaXRoZWltYSIsImV4cCI6MTcwMTkwOTAxNX0.N-MD6DmoeIIY5lB5z73UFLN9u7veppx1K5_N_jS9Yko")
        .getBody();
    System.out.println(claims);
}
```
** 实例：JWT令牌生成 **
```java
//封装为工具类
package com.itheima.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

import java.util.Date;
import java.util.Map;

public class JwtUtils {
    //设置密钥
    private static String signKey = "SVRIRUlNQQ==";
    //设置过期时间
    private static Long expire = 43200000L;

    /**
     * 生成JWT令牌
     * @param Map<String,Object> claim
     * @return JWT
     */

    //要传MAP自定义共享数据
    public static String generateJwt(Map<String,Object> claims){
        String jwt = Jwts.builder()
                .addClaims(claims)
                .signWith(SignatureAlgorithm.HS256, signKey)
                .setExpiration(new Date(System.currentTimeMillis() + expire))
                .compact();
        return jwt;
    }

    /**
     * 解析JWT令牌
     * @param jwt JWT令牌
     * @return JWT第二部分负载 payload 中存储的内容
     */

    //要传JWT令牌
    public static Claims parseJWT(String jwt){
        Claims claims = Jwts.parser()
                .setSigningKey(signKey)
                .parseClaimsJws(jwt)
                .getBody();
        return claims;
    }
}

@Override
public LoginInfo login(Emp emp) {
    Emp empLogin = empMapper.getUsernameAndPassword(emp);
    if(empLogin != null){
        //1. 生成JWT令牌
        Map<String,Object> dataMap = new HashMap<>();
        dataMap.put("id", empLogin.getId());
        dataMap.put("username", empLogin.getUsername());
        
        String jwt = JwtUtils.generateJwt(dataMap);
        LoginInfo loginInfo = new LoginInfo(empLogin.getId(), empLogin.getUsername(), empLogin.getName(), jwt);
        return loginInfo;
    }
    return null;
}
```
### 优点
  - 支持PC端、移动端
  - 解决集群环境下的认证问题
  - 减轻服务器的存储压力（无需在服务器端存储,存在令牌第二部分里面）
### 缺点
  - 需要自己实现（包括令牌的生成、令牌的传递、令牌的校验）

# 拦截器
- 防止每一个请求都要写token校验，所以可以把token校验放在同一拦截器里校验，校验通过即可放行<br>
** 过滤器Filter  vs  拦截器Interceptor **
- 拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。
- Filter在外，Interceptor在里

## 过滤器Filter
- JavaWeb三大组件(Servlet、Filter、Listener)之一
- 过滤器链优先级取决于类名字母自然排序，A比D先执行
- 拦截路径写在过滤器类上
- 放行方法 ** chain.doFilter(request, response) **
- 启动器要加注解 @ServletComponentScan 开启对Servlet组件的支持

### 基本实现
- 第1步，定义过滤器 ：1.定义一个类，实现 Filter 接口，并重写其所有方法。
- 第2步，配置过滤器：Filter类上加 @WebFilter 注解，配置拦截资源的路径。引导类上加 @ServletComponentScan 开启Servlet组件支持。
```java
//过滤器类
@WebFilter(urlPatterns = "/*") //配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ）
public class DemoFilter implements Filter {     //实现Filter接口的三个方法,init和destroy有默认实现，可以不写
    //初始化方法, web服务器启动, 创建Filter实例时调用, 只调用一次
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("init ...");
    }

    //拦截到请求时,调用该方法,可以调用多次
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException {
        System.out.println("拦截到了请求...");
    }

    //销毁方法, web服务器关闭时调用, 只调用一次
    public void destroy() {
        System.out.println("destroy ... ");
    }
}

//启动类
@ServletComponentScan //开启对Servlet组件的支持
@SpringBootApplication
public class TliasManagementApplication {
    public static void main(String[] args) {
        SpringApplication.run(TliasManagementApplication.class, args);
    }
}
```
### 登录过滤器doFilter方法逻辑具体实现
1. 获取请求url<br>
2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行<br>
3. 获取请求头中的令牌（token）<br>
4. 判断令牌是否存在，如果不存在，响应 401<br>
5. 解析token，如果解析失败，响应 401<br>
6. 放行<br>
7. 放行之后对资源做完操作之后还会回到过滤器执行操作

```java
package com.itheima.filter;

import com.itheima.utils.JwtUtils;
import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.HttpStatus;
import org.springframework.util.StringUtils;
import java.io.IOException;

/**
 * 令牌校验过滤器
 */
@Slf4j
@WebFilter(urlPatterns = "/*")
public class TokenFilter implements Filter {

    @Override
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) resp;
        //1. 获取请求url。
        String url = request.getRequestURL().toString();

        //2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行。
        if(url.contains("login")){ //登录请求
            log.info("登录请求 , 直接放行");
            chain.doFilter(request, response);
            return;
        }

        //3. 获取请求头中的令牌（token）。
        String jwt = request.getHeader("token");

        //4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）。
        if(!StringUtils.hasLength(jwt)){ //jwt为空
            log.info("获取到jwt令牌为空, 返回错误结果");
            response.setStatus(HttpStatus.SC_UNAUTHORIZED);
            return;
        }

        //5. 解析token，如果解析失败，返回错误结果（未登录）。
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) {
            e.printStackTrace();
            log.info("解析令牌失败, 返回错误结果");
            response.setStatus(HttpStatus.SC_UNAUTHORIZED);
            return;
        }

        //6. 放行。
        log.info("令牌合法, 放行");
        chain.doFilter(request , response);

        //7.放行之后对资源做完操作之后还会回到过滤器执行操作
    }

}
```
## 拦截器Interceptor
- Spring提供
- 在 ** registry.addInterceptor(demoInterceptor).addPathPatterns() ** 配置路径
- 放行看方法返回值，true为放行
- 要写配置类
```markdown
拦截路径	  含义	                                举例
/*	         一级路径	                能匹配/depts，/emps，/login，不能匹配 /depts/1
/**      	任意级路径               	能匹配/depts，/depts/1，/depts/1/2
/depts/*	/depts下的一级路径	        能匹配/depts/1，不能匹配/depts/1/2，/depts
/depts/**	/depts下的任意级路径     	能匹配/depts，/depts/1，/depts/1/2，不能匹配/emps/1
```
### 基本实现
1. 定义拦截器
2. 注册配置拦截器
```java
//自定义拦截器类
@Component
public class DemoInterceptor implements HandlerInterceptor {
    //目标资源方法执行前执行。 返回true：放行    返回false：不放行
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle .... ");
        
        return true; //true表示放行
    }

    //目标资源方法执行后执行
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle ... ");
    }

    //视图渲染完毕后执行，最后执行（前后端分离用不到）
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion .... ");
    }
}

//注册配置拦截器
/*在 com.itheima下创建一个包，然后创建一个配置类 WebConfig， 实现 WebMvcConfigurer 接口，并重写 addInterceptors 方法*/
@Configuration  
public class WebConfig implements WebMvcConfigurer {

    //自定义的拦截器对象
    @Autowired
    private DemoInterceptor demoInterceptor;

    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
       //注册自定义拦截器对象
        registry.addInterceptor(demoInterceptor).addPathPatterns("/**");//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）
    }
}
```
### 登录过滤器preHandle方法逻辑具体实现
```java
//过滤器类
@Slf4j
@Component
public class TokenInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //1. 获取请求url。
        String url = request.getRequestURL().toString();

        //2. 判断请求url中是否包含login，如果包含，说明是登录操作，放行。
        if(url.contains("login")){ //登录请求
            log.info("登录请求 , 直接放行");
            return true;
        }

        //3. 获取请求头中的令牌（token）。
        String jwt = request.getHeader("token");

        //4. 判断令牌是否存在，如果不存在，返回错误结果（未登录）。
        if(!StringUtils.hasLength(jwt)){ //jwt为空
            log.info("获取到jwt令牌为空, 返回错误结果");
            response.setStatus(HttpStatus.SC_UNAUTHORIZED);
            return false;
        }

        //5. 解析token，如果解析失败，返回错误结果（未登录）。
        try {
            JwtUtils.parseJWT(jwt);
        } catch (Exception e) {
            e.printStackTrace();
            log.info("解析令牌失败, 返回错误结果");
            response.setStatus(HttpStatus.SC_UNAUTHORIZED);
            return false;
        }

        //6. 放行。
        log.info("令牌合法, 放行");
        return true;
    }

}
//配置类
@Configuration  
public class WebConfig implements WebMvcConfigurer {
    //拦截器对象
    @Autowired
    private TokenInterceptor tokenInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
       //注册自定义拦截器对象
        registry.addInterceptor(tokenInterceptor).addPathPatterns("/**");
    }
}

```
