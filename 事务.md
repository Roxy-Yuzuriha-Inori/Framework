Designing Data-Intensive Application（数据密集型应用系统设计）
# 事务的特性ACID
- 原子性（Atomicity）：要么全都完成，要么全都不完成
- 一致性（Consistency）：转账前后数据保持一致
- 隔离性（Isolation）：一个事务不会被另外一个事务干扰
- 持久性（Durability）：一个事务被提交之后，对数据库产生持久性改变

原子性，隔离性，持久性是是手段，是为了一致性的目的

# Spring两种方式的事务管理
## 编程式事务
- TransactionTemplate或者TransactionManager
```java
@Autowired
private TransactionTemplate transactionTemplate;
public void testTransaction() {

        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {

                try {

                    // ....  业务代码
                } catch (Exception e){
                    //回滚
                    transactionStatus.setRollbackOnly();
                }

            }
        });
}
@Autowired
private PlatformTransactionManager transactionManager;

public void testTransaction() {

  TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
          try {
               // ....  业务代码
              transactionManager.commit(status);
          } catch (Exception e) {
              transactionManager.rollback(status);
          }
}
```
## 声明式事务
@Transactional作用于类或方法

# Spring事务接口
- PlatformTransactionManager：（平台）事务管理器，Spring 事务策略的核心。
- TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。
- TransactionStatus：事务运行状态

```java
package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface PlatformTransactionManager {
    //获得事务
    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;
    //提交事务
    void commit(TransactionStatus var1) throws TransactionException;
    //回滚事务
    void rollback(TransactionStatus var1) throws TransactionException;
}
package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    int TIMEOUT_DEFAULT = -1;
    // 返回事务的传播行为，默认值为 REQUIRED。
    int getPropagationBehavior();
    //返回事务的隔离级别，默认值是 DEFAULT
    int getIsolationLevel();
    // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。
    int getTimeout();
    // 返回是否为只读事务，默认值为 false
    boolean isReadOnly();

    @Nullable
    String getName();
}
public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事务
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
}
```
# 事务属性详解
## 事务的传播行为
场景：A调用B的方法，作用于B的事务注解
```java
@Service
Class A {
    @Autowired
    B b;
    @Transactional(propagation = Propagation.REQUIRED)
    public void aMethod {
        //do something
        b.bMethod();
    }
}
@Service
Class B {
    @Transactional(propagation = Propagation.REQUIRED)
    public void bMethod {
       //do something
    }
}
```
### TransactionDefinition.PROPAGATION_REQUIRED
- 默认传播行为
- 如果外部方法没有开启事务的话，Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。
- 如果外部方法开启事务并且被Propagation.REQUIRED的话，所有Propagation.REQUIRED修饰的内部方法和外部方法均属于外部同一事务 ，只要一个方法回滚，整个事务均回滚

### TransactionDefinition.PROPAGATION_REQUIRES_NEW
- 内部新建的事务与外部事务无关
- 内部的完成，外部的不一定完成；内部的完不成，外部的一定完不成<br>
如果我们上面的bMethod()使用PROPAGATION_REQUIRES_NEW事务传播行为修饰，aMethod还是用PROPAGATION_REQUIRED修饰的话。如果aMethod()发生异常回滚，bMethod()不会跟着回滚，因为 bMethod()开启了独立的事务。但是，如果 bMethod()抛出了未被捕获的异常并且这个异常满足事务回滚规则的话,aMethod()同样也会回滚，因为这个异常被 aMethod()的事务管理机制检测到了。

```java
@Service
Class A {
    @Autowired
    B b;
    @Transactional(propagation = Propagation.REQUIRED)
    public void aMethod {
        //do something
        b.bMethod();
    }
}

@Service
Class B {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void bMethod {
       //do something
    }
}
```
### TransactionDefinition.PROPAGATION_NESTED
- 内部新建的事务与外部事务有关
- 在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在。
- 如果外部方法无事务，则单独开启一个事务，与 PROPAGATION_REQUIRED 类似
- 如果 aMethod() 回滚的话，作为嵌套事务的bMethod()会回滚。
- 如果 bMethod() 回滚的话，aMethod()是否回滚，要看bMethod()的异常是否被处理： bMethod()的异常没有被处理，即bMethod()内部没有处理异常，且aMethod()也没有处理异常，那么aMethod()将感知异常致使整体回滚。<br>

*** 如果事务里发生异常但是有异常处理，事务是不会发生回滚的 ***
```java
//b发生异常，b回滚，b中没有处理异常的逻辑，导致异常扩展到了a，A也没有异常处理，导致事务发生异常，进行回滚
@Service
Class A {
    @Autowired
    B b;
    @Transactional(propagation = Propagation.REQUIRED)
    public void aMethod (){
        //do something
        b.bMethod();
    }
}

@Service
Class B {
    @Transactional(propagation = Propagation.NESTED)
    public void bMethod (){
       //do something and throw an exception
    }
}

```
```java
//同样，如果A中有异常处理逻辑，A不回滚，只有B回滚
@Service
Class A {
    @Autowired
    B b;
    @Transactional(propagation = Propagation.REQUIRED)
    public void aMethod (){
        //do something
        try {
            b.bMethod();
        } catch (Exception e) {
            System.out.println("方法回滚");
        }
    }
}

@Service
Class B {
    @Transactional(propagation = Propagation.NESTED)
    public void bMethod {
       //do something and throw an exception
    }
}
```

### TransactionDefinition.PROPAGATION_MANDATORY
- 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）
- 要求调用者必须是个事务，不然报错

### 其他
- TransactionDefinition.PROPAGATION_SUPPORTS: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- TransactionDefinition.PROPAGATION_NOT_SUPPORTED: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- TransactionDefinition.PROPAGATION_NEVER: 以非事务方式运行，如果当前存在事务，则抛出异常。

## 事务的隔离级别
- TransactionDefinition.ISOLATION_DEFAULT :使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别.
- TransactionDefinition.ISOLATION_READ_UNCOMMITTED :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
- TransactionDefinition.ISOLATION_READ_COMMITTED : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
- TransactionDefinition.ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- TransactionDefinition.ISOLATION_SERIALIZABLE : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

## 事务超时属性
- 事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务
- @Transactional(timeout = 30) // 单位：秒
- 默认-1 表示不限制超时时间

## 事务的只读属性
- @Transactional(readOnly = true)
- 作用于只读取数据，不进行修改的操作
- 针对多条数据一起查询
- 对于数据库每一条查询都是一个事务，保证每条查询都是最新的数据；如果加上事务注解，就能将多条查询合并成一个事务

## 事务的回滚属性
- @Transactional(rollbackFor = Exception.class)
- 指定遇到哪些异常才回滚

# SpringAOP自调用问题
method1调用method2的事务方法，不会生效
```java
@Service
public class MyService {

private void method1() {
     method2();
     //......
}
@Transactional
 public void method2() {
     //......
  }
}
```
原因：事务本质是AOP是动态代理，method1要调的是method2的代理方法，而不是method2本身。<br>
在method2的代理方法中，它会拦截调用method2的请求然后来调自己，只有代理对象集成了事务的功能逻辑<br>
所以在一个类中直接调method2不会被代理对象拦截，从而事务不会生效

# 事务注解原理