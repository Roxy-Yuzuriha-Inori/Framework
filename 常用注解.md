
# 标注主启动类
## @SpringBootApplication
- 作用在类上
- 由三个注解组成
@EnableAutoConfiguration：启用 Spring Boot 的自动配置机制。<br>
@ComponentScan：扫描 @Component、@Service、@Repository、@Controller 等注解的类。<br>
@Configuration：允许注册额外的 Spring Bean 或导入其他配置类。<br>

``` java
@SpringBootApplication
public class SpringSecurityJwtGuideApplication {
      public static void main(java.lang.String[] args) {
        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);
    }
}
```
# 依赖注入DI
## @Autowired
- 作用在字段，setter函数，构造器上
- spring提供，先类型后名字匹配

### 字段注入
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository; //字段注入

    public UserDto find(String id) {
        return userRepository.find(id);  //调用注入的方法
    }
 
}
```
### setter函数注入
```java

@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}

```
### 单个构造器注入（推荐）
``` java
@Service
public class ProductService {

    private final ProductRepository productRepository;
    private final PricingService pricingService;

    // Spring 4.3+：对于一个类中只有一个构造器时，可省略 @Autowired
    public ProductService(ProductRepository productRepository,
                          PricingService pricingService) {
        this.productRepository = productRepository;
        this.pricingService = pricingService;
    }
  //调用注入的类的方法
    public ProductDto get(String id) {
        return pricingService.enrich(productRepository.find(id));
    }
}


//Lombok 简化

@Service
@RequiredArgsConstructor // 为所有 final/@NonNull 字段生成构造器
public class InventoryService {

    private final StockRepository stockRepository;
    private final AlarmPublisher alarmPublisher;
}


```
### @RequiredArgsConstructor
- 为所有 final/@NonNull 字段生成构造器
- @NonNull构造器判空
- 字段不能有初值
```java
//lombok原始代码

import lombok.RequiredArgsConstructor;
import lombok.NonNull;

@RequiredArgsConstructor
public class UserService {
    private final String fixed = "already set"; // 已初始化 → 非构造器参数
    private final UserRepository userRepository; // final → 必须参数
    @NonNull
    private ApiClient apiClient;                 // @NonNull → 必须参数（若无默认值）
    private String currentUser;                  // 非 final、无 @NonNull → 非必须参数
}

//实际代码

public class UserService {
    private final String fixed = "already set"; // 已初始化 → 非构造器参数
    private final UserRepository userRepository;
    private ApiClient apiClient;
    private String currentUser;

    // 由 @RequiredArgsConstructor 生成：
    public UserService(UserRepository userRepository, ApiClient apiClient) {
        this.userRepository = userRepository;     // 赋值 final 字段
        if (apiClient == null) {                  // 对 @NonNull 做空值校验
            throw new NullPointerException("apiClient is marked non-null but is null");
        }
        this.apiClient = apiClient;
                                                       //没有fixed和currentUser
    }
}

```
### 多个实现类注入@Qualifier或@Primary
#### 字段
```java
//@Qualifier通过名字指明
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }

@Service
public class UserService {
    @Autowired
    @Qualifier("userRepositoryA") // 指定注入名为 "userRepositoryA" 的 Bean
    private UserRepository userRepository;
    // ...
}
//@Primary设定默认bean
@Primary // 将 UserRepositoryA 设为首选注入对象
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }

@Service
public class UserService {
    @Autowired // 会自动注入 UserRepositoryA，因为它是 @Primary
    private UserRepository userRepository;
    // ...
}
```
#### setter函数
```java
//@Qualifier通过名字指明
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(@Qualifier("userRepositoryA") PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}
//@Primary设定默认bean
@Primary
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}
```
#### 构造器
```java
//@Qualifier通过名字指明
public interface PaymentService {
    void pay(String orderId);
}

@Service("alipayService")
class AlipayService implements PaymentService { /* ... */ }

@Service("wechatService")
class WechatService implements PaymentService { /* ... */ }

@Service
class CheckoutService {
    private final PaymentService paymentService;

    public CheckoutService(@Qualifier("alipayService") PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

//@Primary设定默认bean
@Primary
@Service
class DefaultPaymentService implements PaymentService { /* ... */ }

@Service
class SpecialPaymentService implements PaymentService { /* ... */ }

@Service
class OrderService {
    private final PaymentService paymentService; // 自动注入默认的 DefaultPaymentService

    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


```
## @Resource
- 作用在字段，方法上
- java提供，先名字后类型匹配

### 多个实现类注入
#### 字段
```java
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class UserService {
    @Resource(name = "userRepositoryA")
    private UserRepository userRepository;
    // ...
}

```
### setter函数
```java

@Service
public class OrderService {
    private PaymentClient paymentClient;

    @Resource(name = "wechatClient") // 指定名称
    public void setPaymentClient(PaymentClient paymentClient) {
        this.paymentClient = paymentClient;
    }
}

```
# BEAN
## Bean的作用域
### @Scope("scopeName")
- 作用于bean上（类或方法）
- scopeName:
singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。<br>
prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。<br>
request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。<br>
session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。<br>
application/global-session （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。<br>
websocket （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean<br>

```java
@Component
// 每次获取都会创建新的 PrototypeBean 实例
@Scope("prototype")
public class PrototypeBean {
    // ...
}

```
## Bean的注册
### @Component
- 作用于类上
- 通用标注类为组件的注解
- bean的名字默认是首字母小写
### @Repository
- 作用于持久层类上
- bean的名字默认是首字母小写
### Service
- 作用于服务层类上
- bean的名字默认是首字母小写
### @Controller
- 作用于控制层类上
- bean的名字默认是首字母小写
### @RestController
- 作用于控制层类上
-  @Controller + @ResponseBody
- 返回值自动序列化（通常为JSON）
- bean的名字默认是首字母小写
### @Bean
- 作用于方法上
- 如果第三方bean没有声明将bean交给IOC管理（比如没有@Componet），那么怎么将将第三方的bean交给IOC管理？ 
- 因为不能直接在第三方bean进行修改，所以在启动类或配置类（推荐配置类）中声明一个方法返回这个对象
- bean的名字默认是方法名
# 配置
## 声明配置类
### @Configuration
- 作用于类上
```java
@Configuration
public class AppConfig {

    // @Bean 注解用于在配置类中声明一个 Bean
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

    // 配置类中可以包含一个或多个 @Bean 方法。
}
```
## 读取配置信息
``` yml
wuhan2020: 2020年初武汉爆发了新型冠状病毒

my-profile:
  name: Guide
  email: 123@163.com

library:
  location: 湖北武汉加油中国加油
  books:
    - name: 天才基本法
      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天
    - name: 时间的秩序
      description: 为什么我们记得过去，而非未来？
    - name: 了不起的我
      description: 如何养成一个新习惯？如何让心智变得更成熟？

```
### @Value
- 作用于字段上
- 可设置默认值
```java
@Value("${wuhan2020}")
String wuhan2020;                 // wuhan2020 = "2020年初武汉爆发了新型冠状病毒"

@Value("${my-profile.name：defualt name}")
String name;                     //name = "Guide"  默认值defualt name
```

### @ConfigurationProperties
- 作用于类上


``` yml
app:
  name: demo-app
  features:
    enable-foo: true
    enable-bar: false
  white-list:
    - 192.168.1.10
    - 192.168.1.11
 books:
    - name: 天才基本法
      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天
    - name: 时间的秩序
      description: 为什么我们记得过去，而非未来？
    - name: 了不起的我
      description: 如何养成一个新习惯？如何让心智变得更成熟？
 section:
    music:
        cost: 20
```
*** 与类绑定方法 ***
- 第一层是类AppProperties
- 第二层是第一层类AppProperties的属性，只要有第三层的key,第一层的属性的类型就是第二层以key命名的类
- 编写第一层中以第二层类为数据类型的内部类(Section)，该内部类将第三层的key作为其属性
- 如果还有地四层的key（cost），以此类推
- 第三层Music是第二层类Section的属性，只要有第四层的key(cost),第二层的属性的类型就是第三层以key(Music)命名的类
- 编写第二层以第三层类作为类的内部类（Music）
```java
//pojo

@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    private String name;
    private Features features;
    private List<String> whiteList;
    private List<Book> books;
    private Section section;

    // 内部类：Features
    public static class Features {
        private boolean enableFoo;
        private boolean enableBar;

    //setter与getter
        public boolean isEnableFoo() { return enableFoo; }
        public void setEnableFoo(boolean enableFoo) { this.enableFoo = enableFoo; }
        public boolean isEnableBar() { return enableBar; }
        public void setEnableBar(boolean enableBar) { this.enableBar = enableBar; }
    }

    // 内部类：Book
    public static class Book {
        private String name;
        private String description;

    //setter与getter
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
    }

    // 内部类：Section
    public static class Section {
        private Music music;

        //setter与getter
        public Music getMusic() { return music; }
        public void setMusic(Music music) { this.music = music; }

        public static class Music {
            public int cost;

            //setter与getter
            public int getCost() { return cost; }
            public void setCost(int cost) { this.cost = cost; }
        }
    }

    // Getters & Setters for AppProperties
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public Features getFeatures() { return features; }
    public void setFeatures(Features features) { this.features = features; }

    public void getWhiteList(){ return whiteList; }
    public void setWhiteList(List<String> whiteList) { this.whiteList = whiteList; }

    public List<Book> getBooks() { return books; }
    public void setBooks(List<Book> books) { this.books = books; }

    public Section getSection() { return section; }
    public void setSection(Section section) { this.section = section; }
}

```
- lombok简化 
<br>

*** 对集合类型做好初始化 ***
```java
@Component
@ConfigurationProperties(prefix = "app")
@Data
@NoArgsConstructor
public class AppProperties {


    private String name；
    private Features features; 
//*** 对集合类型做好初始化 ***
    private List<String> whiteList = new ArrayList<>();
    private List<Book> books = new ArrayList<>();

    private Section section; 

    // ---- 嵌套静态类 ----

    @Data
    @NoArgsConstructor
    public static class Features {
        private boolean enableFoo;
        private boolean enableBar;
    }

    @Data
    @NoArgsConstructor
    public static class Book {
        private String name;
        private String description;
    }

    @Data
    @NoArgsConstructor
    public static class Section {
        private Music music;
        @Data
        @NoArgsConstructor
        public static class Music {
            private int cost;
        }
    }
}
//使用

@RestController
public class DemoController {

    private final AppProperties appProperties;
 //构造器注入bean
    public DemoController(AppProperties appProperties) {
        this.appProperties = appProperties;
    }

    @GetMapping("/config")
    public String showConfig() {
        return String.format(
            "App Name: %s, Foo Enabled: %s, First Book: %s, Music Cost: %d",
            appProperties.getName(),
            appProperties.getFeatures().isEnableFoo(), //拿到对象，调用方法
            appProperties.getBooks().get(0).getName(),
            appProperties.getSection().getMusic().getCost()
        );
    }
}

```
### @PropertySource
- 作用于类上
- 加载自定义配置文件

```java
@Component
@PropertySource("classpath:website.properties")  //自定义配置文件路径

class WebSite {
    @Value("${url}")
    private String url;

}
```
# MVC
## HTTP请求
### @GetMapping("users")
- 作用于方法
- 请求从服务器获取特定资源。举个例子：GET /users（获取所有学生）
- 等价于@RequestMapping(value="/users",method=RequestMethod.GET)

```java
@GetMapping("/users")
public ResponseEntity<List<User>> getAllUsers() {
 return userRepository.findAll();
}
```

### @PostMapping("users")
- 作用于方法
- 在服务器上创建一个新的资源。举个例子：POST /users（创建学生）
- 等价于@RequestMapping(value="/users",method=RequestMethod.POST)
- @PostMapping 通常与 @RequestBody 配合，用于接收 JSON 数据并映射为 Java 对象
```java
/*
请求：
curl -X POST http://localhost:8080/api/user \
-H "Content-Type: application/json" \
-d '{"name":"张三","age":25}'
*/


// 定义一个实体类，用于接收 JSON 数据
public class User {
    private String name;
    private int age;

    // Getter 和 Setter
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}


// 控制器类
@RestController
@RequestMapping("/users")
public class UserController {

    // 使用 @PostMapping 接收 JSON 并映射到 User 对象
    @PostMapping("/users")
    public String createUser(@RequestBody User user) {
        return "接收到用户信息：姓名 = " + user.getName() + ", 年龄 = " + user.getAge();
    }
}

```

### @PutMapping("/users/{userId}")
- 作用于方法
- 更新服务器上的资源（客户端提供更新后的整个资源，以JSON形式，所以服务端要有对象接收）。举个例子：PUT /users/12（更新编号为 12 的学生）
- 等价于@RequestMapping(value="/users/{userId}",method=RequestMethod.PUT)

```java
@PutMapping("/users/{userId}")
public ResponseEntity<User> updateUser(@PathVariable(value = "userId") Long userId,
//客户端提供更新后的整个资源，以JSON形式，所以服务端要有对象接收
  @Valid @RequestBody UserUpdateRequest userUpdateRequest) {

}
```

### @DeleteMapping("/users/{userId}")
- 作用于方法
- 从服务器删除特定的资源。举个例子：DELETE /users/12（删除编号为 12 的学生）
- 等价于@RequestMapping(value="/users/{userId}",method=RequestMethod.DELETE)

```java
@DeleteMapping("/users/{userId}")
public ResponseEntity deleteUser(@PathVariable(value = "userId") Long userId){
  ......
}
```
### @PatchMapping("/profile")
- 作用于方法
- 同@PutMapping更新，针对经常只改一两个字段

```java
  @PatchMapping("/profile")
  public ResponseEntity updateStudent(@RequestBody StudentUpdateRequest studentUpdateRequest) {
        studentRepository.updateDetail(studentUpdateRequest);
        return ResponseEntity.ok().build();
    }
```
## 参数绑定
### @PathVariable
- 作用于字段
- 从URL中提取参数

```java
@GetMapping("/klasses/{klassId}/teachers")
public List<Teacher> getTeachersByClass(@PathVariable("klassId") Long klassId) {
    return teacherService.findTeachersByClass(klassId);
}

//若请求 URL 为 /klasses/123/teachers，则 klassId = 123
```

### @RequestParam
- 作用于字段
- 用于绑定查询参数 /users?name=Tom&age=20

```java
@GetMapping("/users")
public String getUser(@RequestParam String name,
                      @RequestParam int age) {  //name=Tom , age = 20
    return "Name: " + name + ", Age: " + age;
}

```

### @RequestBody
- 作用于对象字段
- 用于绑定请求体中body 部分并且Content-Type 为 application/json 格式的 JSON 数据
- 系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的 body 中的 json 字符串转换为 java 对象

```java
//UserRegisterRequest对象
@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserRegisterRequest {
    @NotBlank
    private String userName;
    @NotBlank
    private String password;
    @NotBlank
    private String fullName;
}

//body 携带 JSON 数据：
{ "userName": "coder", "fullName": "shuangkou", "password": "123456" }

@PostMapping("/sign-up")
// UserRegisterRequest 类会存该json数据
public ResponseEntity signUp(@RequestBody @Valid UserRegisterRequest userRegisterRequest) {
  userService.save(userRegisterRequest);
  return ResponseEntity.ok().build();
}

```
*** 注意 ***
- 一个方法只能有一个 @RequestBody 参数，但可以有多个 @PathVariable 和 @RequestParam。
- 如果需要接收多个复杂对象，建议合并成一个单一对象

## 数据校验
- Bean Validation 本身只是一套规范（接口和注解）
- Hibernate Validator 是 Bean Validation 规范的参考实现。
- 添加hibernate-validator依赖
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```
### 字段验证
- @NotNull: 检查被注解的元素（任意类型）不能为 null
- @NotEmpty: 检查被注解的元素（如 CharSequence、Collection、Map、Array）不能为 null 且其大小/长度不能为 0。注意：对于字符串，@NotEmpty 允许包含空白字符的字符串，如 " "。
- @NotBlank: 检查被注解的 CharSequence（如 String）不能为 null，并且去除首尾空格后的长度必须大于 0。（即，不能为空白字符串）。
- @Null: 检查被注解的元素必须为 null
- @AssertTrue / @AssertFalse: 检查被注解的 boolean 或 Boolean 类型元素必须为 true / false。
- @Min(value) / @Max(value): 检查被注解的数字类型（或其字符串表示）的值必须大于等于 / 小于等于指定的 value。适用于整数类型（byte、short、int、long、BigInteger 等）。
- @DecimalMin(value) / @DecimalMax(value): 功能类似 @Min / @Max，但适用于包含小数的数字类型（BigDecimal、BigInteger、CharSequence、byte、short、int、long及其包装类）。 value 必须是数字的字符串表示。
- @Size(min=, max=): 检查被注解的元素（如 CharSequence、Collection、Map、Array）的大小/长度必须在指定的 min 和 max 范围之内（包含边界）。
- @Digits(integer=, fraction=): 检查被注解的数字类型（或其字符串表示）的值，其整数部分的位数必须 ≤ integer，小数部分的位数必须 ≤ fraction。
- @Pattern(regexp=, flags=): 检查被注解的 CharSequence（如 String）是否匹配指定的正则表达式 (regexp)。flags 可以指定匹配模式（如不区分大小写）
- @Email: 检查被注解的 CharSequence（如 String）是否符合 Email 格式（内置了一个相对宽松的正则表达式）。
- @Past / @Future: 检查被注解的日期或时间类型（java.util.Date、java.util.Calendar、JSR 310 java.time 包下的类型）是否在当前时间之前 / 之后。
- @PastOrPresent / @FutureOrPresent: 类似 @Past / @Future，但允许等于当前时间。



### 请求体验证@Valid
- 在@RequestBody后接受json转化为对象的对象前加@Valid 注解来触发对该对象的校验
- 校验写在对象的类中
- 如果验证失败，它将抛出MethodArgumentNotValidException

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Person {
    @NotNull(message = "classId 不能为空")
    private String classId;

    @Size(max = 33)
    @NotNull(message = "name 不能为空")
    private String name;

    @Pattern(regexp = "((^Man$|^Woman$|^UGM$))", message = "sex 值不在可选范围")
    @NotNull(message = "sex 不能为空")
    private String sex;

    @Email(message = "email 格式不正确")
    @NotNull(message = "email 不能为空")
    private String email;
}

/*
*** 关于字段验证的message属性 ***
- 如果写了 BindingResult，Spring 就不会抛异常
- 可以通过Spring自带的bindingResult.getFieldErrors获取FieldError对象
- 再通过FieldError.getDefaultMessage获取到message信息

bindResult常用方法

bindingResult.hasErrors(); // 是否有错误
bindingResult.getFieldErrors(); // 获取字段级错误
bindingResult.getAllErrors(); // 获取所有错误

*/

@RestController
@RequestMapping("/api")

@PostMapping("/create")
public ResponseEntity<?> create(@Valid @RequestBody CourseDto dto, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        List<String> msgs = bindingResult.getFieldErrors()
            .stream().map(FieldError::getDefaultMessage).toList();
        return ResponseEntity.badRequest().body(msgs);
    }
    return ResponseEntity.ok("OK");
}

```
### 请求参数验证
- 第一步，在 Controller 类上添加 @Validated 注解
- 第二步，在@PathVariable("id")或@RequestParam("name")后面加 字段验证

```java
@RestController
@RequestMapping("/api")
@Validated // 关键步骤 1: 必须在类上添加 @Validated
public class PersonController {

    @GetMapping("/person/{id}")
    public ResponseEntity<Integer> getPersonByID(
            @PathVariable("id")
            @Max(value = 5, message = "ID 不能超过 5") // 关键步骤 2: 校验注解直接放在参数上
            Integer id
    ) {
        // 如果传入的 id > 5，Spring 会在进入方法体前抛出 ConstraintViolationException 异常。
        // 全局异常处理器同样需要处理此异常。
        return ResponseEntity.ok().body(id);
    }

    @GetMapping("/person")
    public ResponseEntity<String> findPersonByName(
            @RequestParam("name")
            @NotBlank(message = "姓名不能为空") // 同样适用于 @RequestParam
            @Size(max = 10, message = "姓名长度不能超过 10")
            String name
    ) {
        return ResponseEntity.ok().body("Found person: " + name);
    }
}
```
# 全局异常处理器
## @RestControllerAdvice
- 作用在类上
- @ConrollerAdvice + @ResponseBody：全局异常处理类 + 返回给前端json格式数据

## @ExceptionHandler
- 作用在方法上
- 方法形参表明要处理的异常类型

``` java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler{
  @ExceptionHandler
  public Result handleException(Exception e){  //方法形参表明要处理的异常类型
    log.error("日志记录",e)
    return Result.error("result格式的错误提示信息")
  }
}
```
# 事务
## @Transactional
- 作用于类时：类中的public方法都配置相同的事务属性
- 作用于方法时：方法的事务@Transactional会覆盖类的事务配置信息。
- 不配置rollbackFor属性,那么事务只会在遇到RuntimeException的时候才会回滚
- 配置rollbackFor=Exception.class,可以让事务在遇到非运行时异常时也回滚。

```java
@Transactional(rollbackFor = Exception.class)
public void save() {
}
```

# JSON处理
## 过滤 JSON 字段
### @JsonIgnoreProperties({"属性名"}，ignoreUnknown = true)
- 作用于实例类上
- 过滤掉多个特定字段不返回或者不解析（转换为 JSON 时不会包含 {"属性名"}。从 JSON 转换为对象时，{"属性名"}也不会被赋值。）
- ignoreUnknown = true：忽略未知属性（即 JSON 中有而类中没有的属性不会报错）
```java
@JsonIgnoreProperties(value = {"password", "secretKey"}, ignoreUnknown = true)
public class User {
    private String username;
    private String password;
    private String secretKey;
    private String email;

    // Getter & Setter
}

```
### @JsonIgnore
- 作用于字段或getter/setter 方法级别
- 排除单个具体字段
```java
public class User {
    private String userName;
    private String fullName;
    private String password;

    // 在生成 JSON 时忽略 userRoles 属性
    @JsonIgnore
    private List<UserRole> userRoles = new ArrayList<>();
    // getters and setters...
}
```
### @JsonFormat
- 作用于字段如date或getter/setter 方法
- 序列化（Java对象 -> JSON）和反序列化（JSON -> Java对象）

```java
// 指定 Date 类型序列化为 ISO 8601 格式字符串，并设置时区为 GMT
@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "GMT")
private Date date;
```

*** 属性 ***
- pattern
```java 自定义输出格式
@JsonFormat(pattern = "yyyy-MM-dd") // 例如： 2023-10-27
private Date birthDate;

@JsonFormat(pattern = "HH:mm:ss") // 例如： 14:30:00
private LocalTime startTime;

@JsonFormat(pattern = "yyyy-MM-dd@HH:mm:ss.SSSZ") // 例如： 2023-10-27@14:30:00.123+0800
private Date timestamp;
```

- timezone 指定时区
```java
// 指定为东八区（北京时间）
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
private Date createTime;

// 使用时区ID
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "Asia/Shanghai")
private Date createTime;
```
- shape 指定输出格式
```java
/*
Shape.STRING：将值格式化为字符串（默认用于 Date 等类型）。
Shape.NUMBER：将值（如 Date）表示为时间戳（自 1970-01-01 以来的毫秒数）。
Shape.ARRAY、Shape.OBJECT 等用于其他复杂结构。
*/
// 将日期序列化为时间戳（数字）
@JsonFormat(shape = JsonFormat.Shape.NUMBER)
private Date timestamp; // 输出： 1698384000000

// 将枚举序列为其ordinal（数字），默认为字符串
public enum Status { ACTIVE, INACTIVE }
@JsonFormat(shape = JsonFormat.Shape.NUMBER)
private Status status; // 输出： 0 或 1
```


### @JsonUnwrapped
- 作用于字段
- 扁平化 JSON 对象
- 用于在序列化时将其嵌套对象的属性“提升”到当前对象的层级，反序列化时执行相反操作

```java

@Getter
@Setter
@ToString
public class Account {
    private Location location;
    private PersonInfo personInfo;

  @Getter
  @Setter
  @ToString
  public static class Location {
     private String provinceName;
     private String countyName;
  }
  @Getter
  @Setter
  @ToString
  public static class PersonInfo {
    private String userName;
    private String fullName;
  }
}

//Account对象有两个内部类Location和PersonInfo，对应的json有层级关系
{
  "location": {
    "provinceName": "湖北",
    "countyName": "武汉"
  },
  "personInfo": {
    "userName": "coder1234",
    "fullName": "shaungkou"
  }
}
//对两个内部类进行扁平化
@Getter
@Setter
@ToString
public class Account {
    @JsonUnwrapped     //加载字段定义上
    private Location location;
    @JsonUnwrapped
    private PersonInfo personInfo;
    ......
}
//扁平化后的 JSON 结构：
{
  "provinceName": "湖北",
  "countyName": "武汉",
  "userName": "coder1234",
  "fullName": "shaungkou"
}
```
# 测试
## @SpringBootTest
- 作用于测试抽象基类
*** 属性 ***
- webEnvironment
  - WebEnvironment.MOCK：默认值，使用 Mock Servlet 环境
  - WebEnvironment.RANDOM_PORT：在随机端口启动真实的嵌入式服务器
  - WebEnvironment.DEFINED_PORT：在定义端口启动
  - WebEnvironment.NONE：不提供 Web 环境
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
```
## @ActiveProfiles
- 作用于测试类上
- 用于声明生效的 Spring 配置文件
```java
//激活application-test.properties 或 application-test.yml
@ActiveProfiles("test")

```
## @Test
- 作用于方法
- 标记为测试方法

```java
public class MyServiceTest extends TestBase { // Assuming TestBase provides Spring context

    @Test
    @Transactional // 测试数据将回滚
    @WithMockUser(username = "test-user", authorities = { "ROLE_TEACHER", "read" }) // 模拟一个名为 "test-user"，拥有 TEACHER 角色和 read 权限的用户
    void should_perform_action_requiring_teacher_role() throws Exception {
        // ... 测试逻辑 ...
        // 这里可以调用需要 "ROLE_TEACHER" 权限的服务方法
    }
}
```
## 
# Lombok
## @Builder
- 作用于类
- 初始化类给类赋值可以链式赋值

```java
@Data
@Builder
pubilc class student{
private long id;
private string name;
}

pubilc class Test{
@Autowired
private StudentRepository studentRepository 
 @Test   
 void test(){
    Student student = new Student();
    student.setId(1);
    student.setName("啊")；

    //因为有@Builder链式调用
    student.builder().id(1).name("啊").build();
 }
}

```
# JPA
