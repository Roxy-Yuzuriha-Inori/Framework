# 全局异常处理器
## @RestControllerAdvice
- 作用在类上
- @ConrollerAdvice + @ResponseBody：全局异常处理类 + 返回给前端json格式数据

## @ExceptionHandler
- 作用在方法上
- 方法形参表明要处理的异常类型

``` java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler{
  @ExceptionHandler
  public Result handleException(Exception e){  //方法形参表明要处理的异常类型
    log.error("日志记录",e)
    return Result.error("result格式的错误提示信息")
  }
}
```

# 标注主启动类
## @SpringBootApplication
- 作用在类上
- 由三个注解组成
@EnableAutoConfiguration：启用 Spring Boot 的自动配置机制。<br>
@ComponentScan：扫描 @Component、@Service、@Repository、@Controller 等注解的类。<br>
@Configuration：允许注册额外的 Spring Bean 或导入其他配置类。<br>

``` java
@SpringBootApplication
public class SpringSecurityJwtGuideApplication {
      public static void main(java.lang.String[] args) {
        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);
    }
}
```
# 依赖注入DI
## @Autowired
- 作用在字段，setter函数，构造器上
- spring提供，先类型后名字匹配

### 字段注入
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository; //字段注入

    public UserDto find(String id) {
        return userRepository.find(id);  //调用注入的方法
    }
 
}
```
### setter函数注入
```java

@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}

```
### 单个构造器注入（推荐）
``` java
@Service
public class ProductService {

    private final ProductRepository productRepository;
    private final PricingService pricingService;

    // Spring 4.3+：对于一个类中只有一个构造器时，可省略 @Autowired
    public ProductService(ProductRepository productRepository,
                          PricingService pricingService) {
        this.productRepository = productRepository;
        this.pricingService = pricingService;
    }
  //调用注入的类的方法
    public ProductDto get(String id) {
        return pricingService.enrich(productRepository.find(id));
    }
}


//Lombok 简化

@Service
@RequiredArgsConstructor // 为所有 final/@NonNull 字段生成构造器
public class InventoryService {

    private final StockRepository stockRepository;
    private final AlarmPublisher alarmPublisher;
}


```
### @RequiredArgsConstructor
- 为所有 final/@NonNull 字段生成构造器
- @NonNull构造器判空
- 字段不能有初值
```java
//lombok原始代码

import lombok.RequiredArgsConstructor;
import lombok.NonNull;

@RequiredArgsConstructor
public class UserService {
    private final String fixed = "already set"; // 已初始化 → 非构造器参数
    private final UserRepository userRepository; // final → 必须参数
    @NonNull
    private ApiClient apiClient;                 // @NonNull → 必须参数（若无默认值）
    private String currentUser;                  // 非 final、无 @NonNull → 非必须参数
}

//实际代码

public class UserService {
    private final String fixed = "already set"; // 已初始化 → 非构造器参数
    private final UserRepository userRepository;
    private ApiClient apiClient;
    private String currentUser;

    // 由 @RequiredArgsConstructor 生成：
    public UserService(UserRepository userRepository, ApiClient apiClient) {
        this.userRepository = userRepository;     // 赋值 final 字段
        if (apiClient == null) {                  // 对 @NonNull 做空值校验
            throw new NullPointerException("apiClient is marked non-null but is null");
        }
        this.apiClient = apiClient;
                                                       //没有fixed和currentUser
    }
}

```
### 多个实现类注入@Qualifier或@Primary
#### 字段
```java
//@Qualifier通过名字指明
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }

@Service
public class UserService {
    @Autowired
    @Qualifier("userRepositoryA") // 指定注入名为 "userRepositoryA" 的 Bean
    private UserRepository userRepository;
    // ...
}
//@Primary设定默认bean
@Primary // 将 UserRepositoryA 设为首选注入对象
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }

@Service
public class UserService {
    @Autowired // 会自动注入 UserRepositoryA，因为它是 @Primary
    private UserRepository userRepository;
    // ...
}
```
#### setter函数
```java
//@Qualifier通过名字指明
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(@Qualifier("userRepositoryA") PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}
//@Primary设定默认bean
@Primary
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}
```
#### 构造器
```java
//@Qualifier通过名字指明
public interface PaymentService {
    void pay(String orderId);
}

@Service("alipayService")
class AlipayService implements PaymentService { /* ... */ }

@Service("wechatService")
class WechatService implements PaymentService { /* ... */ }

@Service
class CheckoutService {
    private final PaymentService paymentService;

    public CheckoutService(@Qualifier("alipayService") PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

//@Primary设定默认bean
@Primary
@Service
class DefaultPaymentService implements PaymentService { /* ... */ }

@Service
class SpecialPaymentService implements PaymentService { /* ... */ }

@Service
class OrderService {
    private final PaymentService paymentService; // 自动注入默认的 DefaultPaymentService

    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


```
## @Resource
- 作用在字段，方法上
- java提供，先名字后类型匹配

### 多个实现类注入
#### 字段
```java
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class UserService {
    @Resource(name = "userRepositoryA")
    private UserRepository userRepository;
    // ...
}

```
### setter函数
```java

@Service
public class OrderService {
    private PaymentClient paymentClient;

    @Resource(name = "wechatClient") // 指定名称
    public void setPaymentClient(PaymentClient paymentClient) {
        this.paymentClient = paymentClient;
    }
}

```
# BEAN
## Bean的作用域
### @Scope("scopeName")
- 作用于bean上（类或方法）
- scopeName:
singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。<br>
prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。<br>
request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。<br>
session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。<br>
application/global-session （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。<br>
websocket （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean<br>

```java
@Component
// 每次获取都会创建新的 PrototypeBean 实例
@Scope("prototype")
public class PrototypeBean {
    // ...
}

```
## Bean的注册
### @Component
- 作用于类上
- 通用标注类为组件的注解
### @Repository
- 作用于持久层类上
### Service
- 作用于服务层类上
### @Controller
- 作用于控制层类上
### @RestController
- 作用于控制层类上
-  @Controller + @ResponseBody
- 返回值自动序列化（通常为JSON）

# 配置
## 声明配置类
### @Configuration
- 作用于类上
```java
@Configuration
public class AppConfig {

    // @Bean 注解用于在配置类中声明一个 Bean
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

    // 配置类中可以包含一个或多个 @Bean 方法。
}
```
## 读取配置信息
``` yml
wuhan2020: 2020年初武汉爆发了新型冠状病毒

my-profile:
  name: Guide
  email: 123@163.com

library:
  location: 湖北武汉加油中国加油
  books:
    - name: 天才基本法
      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天
    - name: 时间的秩序
      description: 为什么我们记得过去，而非未来？
    - name: 了不起的我
      description: 如何养成一个新习惯？如何让心智变得更成熟？

```
### @Value
- 作用于字段上
- 可设置默认值
```java
@Value("${wuhan2020}")
String wuhan2020;                 // wuhan2020 = "2020年初武汉爆发了新型冠状病毒"

@Value("${my-profile.name：defualt name}")
String name;                     //name = "Guide"  默认值defualt name
```

### @ConfigurationProperties
- 作用于类上


``` yml
app:
  name: demo-app
  features:
    enable-foo: true
    enable-bar: false
  white-list:
    - 192.168.1.10
    - 192.168.1.11
 books:
    - name: 天才基本法
      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天
    - name: 时间的秩序
      description: 为什么我们记得过去，而非未来？
    - name: 了不起的我
      description: 如何养成一个新习惯？如何让心智变得更成熟？
 section:
    music:
        cost: 20
```
* 与类绑定方法
- 第二层之后不存在键值对，外部类AppProperties属性用基本数据类型（String，List）
- 第二层之后还有键值对，第三层后没有键值对，外部类AppProperties属性用第二层的名字作为类或泛型为该类的集合来作为数据类型，在类中的内部类用第三层的key作为属性名
- 第三层后还有键值对，内部类中在建内部类

```java
//pojo

@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    private String name;
    private Features features;
    private List<String> whiteList;
    private List<Book> books;
    private Section section;

    // 内部类：Features
    public static class Features {
        private boolean enableFoo;
        private boolean enableBar;

        public boolean isEnableFoo() { return enableFoo; }
        public void setEnableFoo(boolean enableFoo) { this.enableFoo = enableFoo; }

        public boolean isEnableBar() { return enableBar; }
        public void setEnableBar(boolean enableBar) { this.enableBar = enableBar; }
    }

    // 内部类：Book
    public static class Book {
        private String name;
        private String description;

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
    }

    // 内部类：Section
    public static class Section {
        private Music music;

        public Music getMusic() { return music; }
        public void setMusic(Music music) { this.music = music; }

        public static class Music {
                       public int getCost() { return cost; }
            public void setCost(int cost) { this.cost = cost; }
        }
    }

    // Getters & Setters for AppProperties
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public Features getFeatures() { return features; }
    public void setFeatures(Features features) { this.features = features; }

    { return whiteList; }
    public void setWhiteList(List<String> whiteList) { this.whiteList = whiteList; }

    public List<Book> getBooks() { return books; }
    public void setBooks(List<Book> books) { this.books = books; }

    public Section getSection() { return section; }
    public void setSection(Section section) { this.section = section; }
}

//简化
package com.example.config;

import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
@ConfigurationProperties(prefix = "app")
@Data
@NoArgsConstructor
public class AppProperties {

    /** app.name */
    private String name;

    /** app.features.* */
    private Features features; // 可选择默认 new Features()

    /** app.white-list -> whiteList */
    private List<String> whiteList = new ArrayList<>();

    /** app.books -> 列表对象绑定 */
    private List<Book> books = new ArrayList<>();

    /** app.section.* */
    private Section section; // 可选择默认 new Section()

    // ---- 嵌套静态类 ----

    @Data
    @NoArgsConstructor
    public static class Features {
        /** app.features.enable-foo */
        private boolean enableFoo;
        /** app.features.enable-bar */
        private boolean enableBar;
    }

    @Data
    @NoArgsConstructor
    public static class Book {
        /** app.books[].name */
        private String name;
        /** app.books[].description */
        private String description;
    }

    @Data
    @NoArgsConstructor
    public static class Section {
        /** app.section.music.* */
        private Music music; // 可选择默认 new Music()

        @Data
        @NoArgsConstructor
        public static class Music {
            /** app.section.music.cost */
            private int cost;
        }
    }
}
//使用

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DemoController {

    private final AppProperties appProperties;

    public DemoController(AppProperties appProperties) {
        this.appProperties = appProperties;
    }

    @GetMapping("/config")
    public String showConfig() {
        return String.format(
            "App Name: %s, Foo Enabled: %s, First Book: %s, Music Cost: %d",
            appProperties.getName(),
            appProperties.getFeatures().isEnableFoo(),
            appProperties.getBooks().get(0).getName(),
            appProperties.getSection().getMusic().getCost()
        );
    }
}
//lombok
package com.example.web;

import com.example.config.AppProperties;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor // 自动生成构造器注入
public class ConfigController {

    private final AppProperties props;

    @GetMapping("/config")
    public String show() {
        var firstBook = props.getBooks().isEmpty() ? "无" : props.getBooks().get(0).getName();
        var musicCost = props.getSection() != null && props.getSection().getMusic() != null
                ? props.getSection().getMusic().getCost() : -1;

        return String.format(
                "name=%s, foo=%s, whiteList=%s, firstBook=%s, musicCost=%d",
                props.getName(),
                props.getFeatures() != null && props.getFeatures().isEnableFoo(),
                props.getWhiteList(),
                firstBook,
                musicCost
        );
    }
}

```
