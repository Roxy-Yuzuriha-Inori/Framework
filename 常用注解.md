# 全局异常处理器
## @RestControllerAdvice
- 作用在类上
- @ConrollerAdvice + @ResponseBody：全局异常处理类 + 返回给前端json格式数据

## @ExceptionHandler
- 作用在方法上
- 方法形参表明要处理的异常类型

``` java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler{
  @ExceptionHandler
  public Result handleException(Exception e){  //方法形参表明要处理的异常类型
    log.error("日志记录",e)
    return Result.error("result格式的错误提示信息")
  }
}
```

# 标注主启动类
## @SpringBootApplication
- 作用在类上
- 由三个注解组成
@EnableAutoConfiguration：启用 Spring Boot 的自动配置机制。<br>
@ComponentScan：扫描 @Component、@Service、@Repository、@Controller 等注解的类。<br>
@Configuration：允许注册额外的 Spring Bean 或导入其他配置类。<br>

``` java
@SpringBootApplication
public class SpringSecurityJwtGuideApplication {
      public static void main(java.lang.String[] args) {
        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);
    }
}
```
# 依赖注入DI
## @Autowired
- 作用在字段，setter函数，构造器上
- spring提供，先类型后名字匹配

### 字段注入
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository; //字段注入

    public UserDto find(String id) {
        return userRepository.find(id);  //调用注入的方法
    }
 
}
```
### setter函数注入
```java

@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}

```
### 单个构造器注入（推荐）
``` java
@Service
public class ProductService {

    private final ProductRepository productRepository;
    private final PricingService pricingService;

    // Spring 4.3+：对于一个类中只有一个构造器时，可省略 @Autowired
    public ProductService(ProductRepository productRepository,
                          PricingService pricingService) {
        this.productRepository = productRepository;
        this.pricingService = pricingService;
    }
  //调用注入的类的方法
    public ProductDto get(String id) {
        return pricingService.enrich(productRepository.find(id));
    }
}


//Lombok 简化

@Service
@RequiredArgsConstructor // 为所有 final/@NonNull 字段生成构造器
public class InventoryService {

    private final StockRepository stockRepository;
    private final AlarmPublisher alarmPublisher;
}


```
### @RequiredArgsConstructor
- 为所有 final/@NonNull 字段生成构造器
- @NonNull构造器判空
- 字段不能有初值
```java
//lombok原始代码

import lombok.RequiredArgsConstructor;
import lombok.NonNull;

@RequiredArgsConstructor
public class UserService {
    private final String fixed = "already set"; // 已初始化 → 非构造器参数
    private final UserRepository userRepository; // final → 必须参数
    @NonNull
    private ApiClient apiClient;                 // @NonNull → 必须参数（若无默认值）
    private String currentUser;                  // 非 final、无 @NonNull → 非必须参数
}

//实际代码

public class UserService {
    private final String fixed = "already set"; // 已初始化 → 非构造器参数
    private final UserRepository userRepository;
    private ApiClient apiClient;
    private String currentUser;

    // 由 @RequiredArgsConstructor 生成：
    public UserService(UserRepository userRepository, ApiClient apiClient) {
        this.userRepository = userRepository;     // 赋值 final 字段
        if (apiClient == null) {                  // 对 @NonNull 做空值校验
            throw new NullPointerException("apiClient is marked non-null but is null");
        }
        this.apiClient = apiClient;
                                                       //没有fixed和currentUser
    }
}

```
### 多个实现类注入@Qualifier或@Primary
#### 字段
```java
//@Qualifier通过名字指明
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }

@Service
public class UserService {
    @Autowired
    @Qualifier("userRepositoryA") // 指定注入名为 "userRepositoryA" 的 Bean
    private UserRepository userRepository;
    // ...
}
//@Primary设定默认bean
@Primary // 将 UserRepositoryA 设为首选注入对象
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }

@Service
public class UserService {
    @Autowired // 会自动注入 UserRepositoryA，因为它是 @Primary
    private UserRepository userRepository;
    // ...
}
```
#### setter函数
```java
//@Qualifier通过名字指明
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(@Qualifier("userRepositoryA") PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}
//@Primary设定默认bean
@Primary
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}
```
#### 构造器
```java
//@Qualifier通过名字指明
public interface PaymentService {
    void pay(String orderId);
}

@Service("alipayService")
class AlipayService implements PaymentService { /* ... */ }

@Service("wechatService")
class WechatService implements PaymentService { /* ... */ }

@Service
class CheckoutService {
    private final PaymentService paymentService;

    public CheckoutService(@Qualifier("alipayService") PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

//@Primary设定默认bean
@Primary
@Service
class DefaultPaymentService implements PaymentService { /* ... */ }

@Service
class SpecialPaymentService implements PaymentService { /* ... */ }

@Service
class OrderService {
    private final PaymentService paymentService; // 自动注入默认的 DefaultPaymentService

    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


```
## @Resource
- 作用在字段，方法上
- java提供，先名字后类型匹配

### 多个实现类注入
#### 字段
```java
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class UserService {
    @Resource(name = "userRepositoryA")
    private UserRepository userRepository;
    // ...
}

```
### setter函数
```java

@Service
public class OrderService {
    private PaymentClient paymentClient;

    @Resource(name = "wechatClient") // 指定名称
    public void setPaymentClient(PaymentClient paymentClient) {
        this.paymentClient = paymentClient;
    }
}

```
# BEAN
## Bean的作用域
### @Scope("scopeName")
- 作用于bean上（类或方法）
- scopeName:
singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。<br>
prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。<br>
request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。<br>
session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。<br>
application/global-session （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。<br>
websocket （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean<br>

```java
@Component
// 每次获取都会创建新的 PrototypeBean 实例
@Scope("prototype")
public class PrototypeBean {
    // ...
}

```
## Bean的注册
### @Component
- 
