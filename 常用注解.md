# 全局异常处理器
## @RestControllerAdvice
- 作用在类上
- @ConrollerAdvice + @ResponseBody：全局异常处理类 + 返回给前端json格式数据

## @ExceptionHandler
- 作用在方法上
- 方法形参表明要处理的异常类型

``` java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler{
  @ExceptionHandler
  public Result handleException(Exception e){  //方法形参表明要处理的异常类型
    log.error("日志记录",e)
    return Result.error("result格式的错误提示信息")
  }
}
```

# 标注主启动类
## @SpringBootApplication
- 作用在类上
- 由三个注解组成
@EnableAutoConfiguration：启用 Spring Boot 的自动配置机制。<br>
@ComponentScan：扫描 @Component、@Service、@Repository、@Controller 等注解的类。<br>
@Configuration：允许注册额外的 Spring Bean 或导入其他配置类。<br>

``` java
@SpringBootApplication
public class SpringSecurityJwtGuideApplication {
      public static void main(java.lang.String[] args) {
        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);
    }
}
```
# 依赖注入DI
## @Autowired
- 作用在字段，setter函数，构造器上
- spring提供，先类型后名字匹配

### 字段注入
```java
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository; //字段注入

    public UserDto find(String id) {
        return userRepository.find(id);  //调用注入的方法
    }
 
}
```
### setter函数注入
```java

@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}

```
### 单个构造器注入（推荐）
``` java
@Service
public class ProductService {

    private final ProductRepository productRepository;
    private final PricingService pricingService;

    // Spring 4.3+：对于一个类中只有一个构造器时，可省略 @Autowired
    public ProductService(ProductRepository productRepository,
                          PricingService pricingService) {
        this.productRepository = productRepository;
        this.pricingService = pricingService;
    }
  //调用注入的类的方法
    public ProductDto get(String id) {
        return pricingService.enrich(productRepository.find(id));
    }
}


//Lombok 简化

@Service
@RequiredArgsConstructor // 为所有 final/@NonNull 字段生成构造器
public class InventoryService {

    private final StockRepository stockRepository;
    private final AlarmPublisher alarmPublisher;
}


```
### @RequiredArgsConstructor
- 为所有 final/@NonNull 字段生成构造器
- @NonNull构造器判空
- 字段不能有初值
```java
//lombok原始代码

import lombok.RequiredArgsConstructor;
import lombok.NonNull;

@RequiredArgsConstructor
public class UserService {
    private final String fixed = "already set"; // 已初始化 → 非构造器参数
    private final UserRepository userRepository; // final → 必须参数
    @NonNull
    private ApiClient apiClient;                 // @NonNull → 必须参数（若无默认值）
    private String currentUser;                  // 非 final、无 @NonNull → 非必须参数
}

//实际代码

public class UserService {
    private final String fixed = "already set"; // 已初始化 → 非构造器参数
    private final UserRepository userRepository;
    private ApiClient apiClient;
    private String currentUser;

    // 由 @RequiredArgsConstructor 生成：
    public UserService(UserRepository userRepository, ApiClient apiClient) {
        this.userRepository = userRepository;     // 赋值 final 字段
        if (apiClient == null) {                  // 对 @NonNull 做空值校验
            throw new NullPointerException("apiClient is marked non-null but is null");
        }
        this.apiClient = apiClient;
                                                       //没有fixed和currentUser
    }
}

```
### 多个实现类注入@Qualifier或@Primary
#### 字段
```java
//@Qualifier通过名字指明
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }

@Service
public class UserService {
    @Autowired
    @Qualifier("userRepositoryA") // 指定注入名为 "userRepositoryA" 的 Bean
    private UserRepository userRepository;
    // ...
}
//@Primary设定默认bean
@Primary // 将 UserRepositoryA 设为首选注入对象
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }

@Service
public class UserService {
    @Autowired // 会自动注入 UserRepositoryA，因为它是 @Primary
    private UserRepository userRepository;
    // ...
}
```
#### setter函数
```java
//@Qualifier通过名字指明
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(@Qualifier("userRepositoryA") PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}
//@Primary设定默认bean
@Primary
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class OrderService {

    private PaymentClient paymentClient;

    @Autowired
    public void setPaymentClient(PaymentClient paymentClient) { // setter 注入
        this.paymentClient = paymentClient;
    }

    public void pay(String orderId) {
        paymentClient.charge(orderId);
    }
}
```
#### 构造器
```java
//@Qualifier通过名字指明
public interface PaymentService {
    void pay(String orderId);
}

@Service("alipayService")
class AlipayService implements PaymentService { /* ... */ }

@Service("wechatService")
class WechatService implements PaymentService { /* ... */ }

@Service
class CheckoutService {
    private final PaymentService paymentService;

    public CheckoutService(@Qualifier("alipayService") PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

//@Primary设定默认bean
@Primary
@Service
class DefaultPaymentService implements PaymentService { /* ... */ }

@Service
class SpecialPaymentService implements PaymentService { /* ... */ }

@Service
class OrderService {
    private final PaymentService paymentService; // 自动注入默认的 DefaultPaymentService

    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}


```
## @Resource
- 作用在字段，方法上
- java提供，先名字后类型匹配

### 多个实现类注入
#### 字段
```java
@Repository("userRepositoryA")
public class UserRepositoryA implements UserRepository { /* ... */ }

@Repository("userRepositoryB")
public class UserRepositoryB implements UserRepository { /* ... */ }
@Service
public class UserService {
    @Resource(name = "userRepositoryA")
    private UserRepository userRepository;
    // ...
}

```
### setter函数
```java

@Service
public class OrderService {
    private PaymentClient paymentClient;

    @Resource(name = "wechatClient") // 指定名称
    public void setPaymentClient(PaymentClient paymentClient) {
        this.paymentClient = paymentClient;
    }
}

```
# BEAN
## Bean的作用域
### @Scope("scopeName")
- 作用于bean上（类或方法）
- scopeName:
singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。<br>
prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。<br>
request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。<br>
session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。<br>
application/global-session （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。<br>
websocket （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean<br>

```java
@Component
// 每次获取都会创建新的 PrototypeBean 实例
@Scope("prototype")
public class PrototypeBean {
    // ...
}

```
## Bean的注册
### @Component
- 作用于类上
- 通用标注类为组件的注解
### @Repository
- 作用于持久层类上
### Service
- 作用于服务层类上
### @Controller
- 作用于控制层类上
### @RestController
- 作用于控制层类上
-  @Controller + @ResponseBody
- 返回值自动序列化（通常为JSON）

# 配置
## 声明配置类
### @Configuration
- 作用于类上
```java
@Configuration
public class AppConfig {

    // @Bean 注解用于在配置类中声明一个 Bean
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

    // 配置类中可以包含一个或多个 @Bean 方法。
}
```
## 读取配置信息
``` yml
wuhan2020: 2020年初武汉爆发了新型冠状病毒

my-profile:
  name: Guide
  email: 123@163.com

library:
  location: 湖北武汉加油中国加油
  books:
    - name: 天才基本法
      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天
    - name: 时间的秩序
      description: 为什么我们记得过去，而非未来？
    - name: 了不起的我
      description: 如何养成一个新习惯？如何让心智变得更成熟？

```
### @Value
- 作用于字段上
- 可设置默认值
```java
@Value("${wuhan2020}")
String wuhan2020;                 // wuhan2020 = "2020年初武汉爆发了新型冠状病毒"

@Value("${my-profile.name：defualt name}")
String name;                     //name = "Guide"  默认值defualt name
```

### @ConfigurationProperties
- 作用于类上


``` yml
app:
  name: demo-app
  features:
    enable-foo: true
    enable-bar: false
  white-list:
    - 192.168.1.10
    - 192.168.1.11
 books:
    - name: 天才基本法
      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天
    - name: 时间的秩序
      description: 为什么我们记得过去，而非未来？
    - name: 了不起的我
      description: 如何养成一个新习惯？如何让心智变得更成熟？
 section:
    music:
        cost: 20
```
*** 与类绑定方法 ***
- 第一层是类AppProperties
- 第二层是第一层类AppProperties的属性，只要有第三层的key,第一层的属性的类型就是第二层以key命名的类
- 编写第一层中以第二层类为数据类型的内部类(Section)，该内部类将第三层的key作为其属性
- 如果还有地四层的key（cost），以此类推
- 第三层Music是第二层类Section的属性，只要有第四层的key(cost),第二层的属性的类型就是第三层以key(Music)命名的类
- 编写第二层以第三层类作为类的内部类（Music）
```java
//pojo

@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    private String name;
    private Features features;
    private List<String> whiteList;
    private List<Book> books;
    private Section section;

    // 内部类：Features
    public static class Features {
        private boolean enableFoo;
        private boolean enableBar;

    //setter与getter
        public boolean isEnableFoo() { return enableFoo; }
        public void setEnableFoo(boolean enableFoo) { this.enableFoo = enableFoo; }
        public boolean isEnableBar() { return enableBar; }
        public void setEnableBar(boolean enableBar) { this.enableBar = enableBar; }
    }

    // 内部类：Book
    public static class Book {
        private String name;
        private String description;

    //setter与getter
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
    }

    // 内部类：Section
    public static class Section {
        private Music music;

        //setter与getter
        public Music getMusic() { return music; }
        public void setMusic(Music music) { this.music = music; }

        public static class Music {
            public int cost;

            //setter与getter
            public int getCost() { return cost; }
            public void setCost(int cost) { this.cost = cost; }
        }
    }

    // Getters & Setters for AppProperties
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public Features getFeatures() { return features; }
    public void setFeatures(Features features) { this.features = features; }

    public void getWhiteList(){ return whiteList; }
    public void setWhiteList(List<String> whiteList) { this.whiteList = whiteList; }

    public List<Book> getBooks() { return books; }
    public void setBooks(List<Book> books) { this.books = books; }

    public Section getSection() { return section; }
    public void setSection(Section section) { this.section = section; }
}

```
- lombok简化 
<br>

*** 对集合类型做好初始化 ***
```java
@Component
@ConfigurationProperties(prefix = "app")
@Data
@NoArgsConstructor
public class AppProperties {


    private String name；
    private Features features; 
//*** 对集合类型做好初始化 ***
    private List<String> whiteList = new ArrayList<>();
    private List<Book> books = new ArrayList<>();

    private Section section; 

    // ---- 嵌套静态类 ----

    @Data
    @NoArgsConstructor
    public static class Features {
        private boolean enableFoo;
        private boolean enableBar;
    }

    @Data
    @NoArgsConstructor
    public static class Book {
        private String name;
        private String description;
    }

    @Data
    @NoArgsConstructor
    public static class Section {
        private Music music;
        @Data
        @NoArgsConstructor
        public static class Music {
            private int cost;
        }
    }
}
//使用

@RestController
public class DemoController {

    private final AppProperties appProperties;
 //构造器注入bean
    public DemoController(AppProperties appProperties) {
        this.appProperties = appProperties;
    }

    @GetMapping("/config")
    public String showConfig() {
        return String.format(
            "App Name: %s, Foo Enabled: %s, First Book: %s, Music Cost: %d",
            appProperties.getName(),
            appProperties.getFeatures().isEnableFoo(), //拿到对象，调用方法
            appProperties.getBooks().get(0).getName(),
            appProperties.getSection().getMusic().getCost()
        );
    }
}

```
### @PropertySource
- 作用于类上
- 加载自定义配置文件

```java
@Component
@PropertySource("classpath:website.properties")  //自定义配置文件路径

class WebSite {
    @Value("${url}")
    private String url;

}
```
# MVC
## HTTP请求
### GET
## 参数绑定

## 数据校验
